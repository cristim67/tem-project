\documentclass[12pt, a4paper, twoside, openright]{report}

% --- Pachete Fundamentale ---
\usepackage[utf8]{inputenc}
\usepackage[romanian]{babel}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\geometry{
 a4paper,
 left=25mm,
 right=25mm,
 top=25mm,
 bottom=25mm,
}
\usepackage{graphicx}
\usepackage{float}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning,calc}

% --- Stiluri Link-uri ---
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=magenta,      
    urlcolor=blue,
    citecolor=black,
}

% --- Stiluri Cod ---
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\small, % Cod un pic mai mare
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    literate={ă}{{\u{a}}}1 {ș}{{\c{s}}}1 {ț}{{\c{t}}}1 {î}{{\^i}}1 {â}{{\^a}}1 {Ă}{{\u{A}}}1 {Ș}{{\c{S}}}1 {Ț}{{\c{T}}}1 {Î}{{\^I}}1 {Â}{{\^A}}1
}
\lstset{style=mystyle}

% --- Definitie Limbaj JavaScript ---
\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break, const, let, async, await, export, default, import, from},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\begin{document}

% --- PAGINA DE TITLU ---
\begin{titlepage}
    \begin{center}
        \vspace*{1cm}
        
        \Large
        \textbf{UNIVERSITATEA POLITEHNICA DIN BUCUREȘTI}
        
        \vspace{0.5cm}
        Facultatea de Electronică, Telecomunicații și Tehnologia Informației
        
        \vspace{4cm}
        
        \Huge
        \textbf{Streaming Video Live pe Internet: Principii, Specificații și Implementarea unei Platforme de Comunicație în Timp Real}
        
        \vspace{0.5cm}
        \Large
        \textit{- Temă de Proiect -}
        
        \vspace{4cm}
        
        \textbf{Student:} Ing. Cristi Miloiu
        
        \textbf{Coordonator:} Prof. Dr. Ing. Radu Rădescu
        
        \vfill
        
        \Large
        București\\
        2025
        
    \end{center}
\end{titlepage}

% --- CUPRINS ---
\tableofcontents
\newpage

% --- CAPITOLUL 1 ---
\chapter{Introducere}

\section{Context General și Motivația Cercetării}
Evoluția recentă a infrastructurii globale de internet a catalizat tranziția către comunicarea multimedia în timp real, pilon central al interacțiunii digitale moderne. În spatele interfețelor aparent simple ale platformelor de videoconferință (e.g., Zoom, Google Meet) se află sisteme distribuite complexe, care orchestrează compresia semnalului video, sincronizarea fluxurilor audio-video și optimizarea latenței în condiții variabile de rețea.

Motivația acestui proiect de disertație rezidă în necesitatea de a deconstrui și analiza critic mecanismele fundamentale care guvernează transportul datelor multimedia. Proiectul "StreamFlow" propune o abordare experimentală, evitând abstractizările de nivel înalt (precum WebRTC) pentru a implementa și evalua "de la zero" protocoalele de transport. Această strategie permite o investigație detaliată a compromisurilor tehnice (trade-offs) dintre fiabilitatea transmisiunii (TCP) și latența minimă (UDP), precum și analiza impactului la nivel de aplicație a congestiei rețelei.

\section{Obiectivele Lucrării}
Prezenta lucrare își propune atingerea următoarelor obiective specifice de cercetare și implementare:
\begin{enumerate}
    \item \textbf{Analiza Teoretică a Compresiei Video}: Investigarea algoritmilor de compresie intra-frame (MJPEG) și a tehnicilor de sub-eșantionare cromatică (YUV 4:2:0) pentru optimizarea raportului calitate/bandă.
    \item \textbf{Evaluarea Comparativă a Protocoalelor de Transport}: Analiza empiricǎ a performanței în streaming live, cu accent pe fenomenul de "Head-of-Line Blocking" specific TCP și strategiile de mitigare la nivel de aplicație.
    \item \textbf{Arhitectura și Implementarea Sistemului}: Proiectarea unei arhitecturi Client-Server scalabile (FastAPI, React), capabile să gestioneze concurența ridicată și să asigure o experiență de utilizare fluidă ("low-latency").
    \item \textbf{Studiul Topologiilor de Distribuție}: Compararea arhitecturilor Mesh, MCU și SFU pentru a justifica alegerea modelului Star în contextul limitărilor de bandă ale rețelelor domestice.
\end{enumerate}

\newpage

\section{Stadiul Actual al Tehnologiei}
Pentru a plasa soluția propusă în contextul tehnologic actual, este necesară o analiză a standardelor consacrate pentru streaming video. În prezent, ecosistemul este polarizat între două extreme:

\subsection{Soluții bazate pe Segmente (HLS, DASH)}
Protocoale precum \textbf{HLS (HTTP Live Streaming)} de la Apple și \textbf{MPEG-DASH} funcționează prin divizarea fluxului video în fișiere mici (chunks) cu durate de 2-10 secunde, descărcate progresiv prin HTTP obișnuit.
\begin{itemize}
    \item \textbf{Avantaje}: Scalabilitate masivă (folosind CDN-uri standard), trecere ușoară prin firewall-uri.
    \item \textbf{Dezavantaje}: Latență inerentă mare (15-30 secunde), improprie pentru interacțiune bidirecțională.
\end{itemize}

\subsection{Soluții Peer-to-Peer (WebRTC)}
\textbf{WebRTC (Web Real-Time Communication)} este standardul de aur pentru latență sub o secundă (< 500ms). Utilizează UDP, criptare obligatorie (DTLS-SRTP) și o arhitectură complexă de negociere a conexiunii.
\begin{itemize}
    \item \textbf{Complexitate}: Necesită servere STUN/TURN pentru a penetra NAT-urile (Network Address Translation) și procesul de semnalizare SDP (Session Description Protocol).
    \item \textbf{Justificarea StreamFlow}: Deși WebRTC este superior tehnic, complexitatea sa de implementare este o barieră semnificativă. StreamFlow demonstrează că se poate obține o latență acceptabilă (\textasciitilde 100ms) folosind tehnologii mult mai simple (WebSocket), eliminând necesitatea infrastructurii ICE (Interactive Connectivity Establishment).
\end{itemize}

\section{Structura Lucrării}
Documentația este structurată în 7 capitole esențiale:
\begin{itemize}
    \item \textbf{Cap. 1} prezintă contextul general, motivația și obiectivele proiectului.
    \item \textbf{Cap. 2} sintetizează teoria semnalului video și compresia, punând accent pe conceptele fundamentale.
    \item \textbf{Cap. 3} analizează rețeaua și justifică alegerea protocoalelor.
    \item \textbf{Cap. 4} descrie arhitectura și implementarea efectivă a platformei StreamFlow.
    \item \textbf{Cap. 5} evaluează performanța sistemului și scenariile de testare.
    \item \textbf{Cap. 6} propune direcții viitoare de dezvoltare (WebTransport, AI).
    \item \textbf{Cap. 7} conține concluziile finale și lecțiile desprinse.
\end{itemize}

% --- CAPITOLUL 2 ---
\chapter{Fundamente Teoretice și Compresie}

\section{De la Lumină la Biți}
Fundamentul transmisiunii video digitale constă în digitizarea semnalului analogic captat de senzorul camerei. Un flux video nerestricționat (RAW) generează un debit de date colosal. De exemplu, un stream 1080p la 30fps în format RGB (24 biți/pixel) necesită:
\begin{equation}
    1920 \times 1080 \times 24 \text{ biți} \times 30 \text{ fps} \approx 1.5 \text{ Gbps}
\end{equation}
Această lățime de bandă depășește capacitatea majorității conexiunilor rezidențiale, impunând utilizarea unor tehnici agresive de compresie.

\subsection{Sub-eșantionarea Cromatică (Chroma Subsampling)}
Retina umană prezintă o densitate mult mai mare a celulelor cu bastonașe (sensibile la intensitate) comparativ cu celulele cu conuri (sensibile la culoare). Ingineria video exploatează această limitare perceptuală prin conversia spațiului de culoare din RGB în YCbCr (sau YUV), unde Y reprezintă Luma (luminozitatea), iar Cb și Cr reprezintă componentele de crominance (diferență de albastru și roșu).

Standardul \textbf{4:2:0}, utilizat în acest proiect, menține rezoluția completă pentru canalul Y, dar sub-eșantionează canalele de culoare la un sfert din rezoluția originală, reducând dimensiunea datelor cu 50\% fără o degradare vizuală semnificativă.

\begin{figure}[htbp]
    \centering
    \begin{tikzpicture}[scale=0.7, transform shape]
        \def\sq{0.8}
        % 4:4:4
        \node at (2, 5) {\textbf{YUV 4:4:4}};
        \foreach \x in {0,1,2,3}
            \foreach \y in {0,1,2,3} {
                \draw[fill=gray!20] (\x*\sq, \y*\sq) rectangle ++(\sq,\sq);
                \draw[fill=black] (\x*\sq+0.4, \y*\sq+0.4) circle (0.15); 
                \draw[blue, thick] (\x*\sq+0.1, \y*\sq+0.1) rectangle ++(0.6,0.6); 
            }
        
        % Arrow
        \draw[->, ultra thick, gray] (3.5, 2) -- (5.5, 2) node[midway, above] {\small Compresie};

        % 4:2:0
        \node at (7, 5) {\textbf{YUV 4:2:0}};
        \foreach \x in {0,1,2,3}
            \foreach \y in {0,1,2,3} {
                \draw[fill=gray!20] (\x*\sq+5.5, \y*\sq) rectangle ++(\sq,\sq);
                \draw[fill=black] (\x*\sq+5.9, \y*\sq+0.4) circle (0.15);
            }
        % Shared Chroma blocks
        \foreach \x in {0,2}
            \foreach \y in {0,2} {
                 \draw[blue, thick] (\x*\sq+5.5, \y*\sq) rectangle ++(2*\sq, 2*\sq);
                 \node[blue] at (\x*\sq+5.5+\sq, \y*\sq+\sq) {\tiny UV};
            }
    \end{tikzpicture}
    \caption{Vizualizarea sub-eșantionării cromatice. Reducerea informației de culoare permite economisirea a 50\% din lățimea de bandă.}
\end{figure}

\section{Transformarea Discretă Cosinus (DCT)}
Nucleul standardului JPEG (și, prin extensie, MJPEG) este Transformarea Discretă Cosinus (DCT). Această operație matematică convertește semnalul din domeniul spațial (amplitudinea pixelilor) în domeniul frecvenței.

Imaginea este divizată în blocuri de $8 \times 8$ pixeli. Fiecare bloc $f(x,y)$ este transformat într-o matrice de coeficienți $F(u,v)$ folosind ecuația:
\begin{equation}
    F(u,v) = \frac{1}{4} C(u)C(v) \sum_{x=0}^{7} \sum_{y=0}^{7} f(x,y) \cos\left[\frac{(2x+1)u\pi}{16}\right] \cos\left[\frac{(2y+1)v\pi}{16}\right]
\end{equation}
unde $C(u), C(v) = 1/\sqrt{2}$ pentru $u,v=0$ și $1$ în rest.

Această transformare concentrează energia semnalului în coeficienții de joasă frecvență (colțul stânga-sus al matricei), deoarece ochiul uman este mult mai puțin sensibil la variațiile de înaltă frecvență. Această proprietate perceptuală permite etapa următoare: cuantizarea.

\subsection{Cuantizarea și Codarea Entropică}
Coeficienții DCT sunt împărțiți element cu element la o matrice de cuantizare $Q(u,v)$ și rotunjiți la cel mai apropiat întreg.
\begin{equation}
    F_{Q}(u,v) = \text{round}\left( \frac{F(u,v)}{Q(u,v)} \right)
\end{equation}
Acesta este singurul pas cu pierdere de informație (lossy). Valorile de frecvență înaltă, care au amplitudini mici, devin adesea zero în urma împărțirii. Șirul rezultat este apoi comprimat fără pierderi folosind codarea Huffman (codare entropică), care asignează coduri binare mai scurte secvențelor de date care apar mai frecvent.

\section{Structura Compresiei JPEG}
Pentru platforma StreamFlow, s-a optat pentru protocolul MJPEG (Motion JPEG), tratând video-ul ca o succesiune de cadre independente comprimate JPEG. Această decizie arhitecturală prioritizează latența scăzută în detrimentul eficienței lățimii de bandă (absența compresiei temporale inter-frame).

Un cadru JPEG este structurat astfel:
\begin{enumerate}
    \item \textbf{SOI (Start of Image)}: Markerul \texttt{0xFFD8} care semnalează începutul fluxului de biți valid.
    \item \textbf{Tabele de Cuantizare (DQT)}: Definiția matricelor care elimină frecvențele spațiale înalte (detaliile fine), controlând factorul de calitate (e.g., Q=50).
    \item \textbf{Date Huffman}: Biții efectivi ai imaginii, codificați entropic.
    \item \textbf{EOI (End of Image)}: Markerul \texttt{0xFFD9}.
\end{enumerate}

Această structură atomică permite decodarea robustă: chiar dacă un pachet de rețea se pierde distrugând un cadru, următorul cadru (care începe cu noi markeri SOI) va fi decodat perfect, eliminând artefactele vizuale persistente specifice codecurilor precum H.264 (până la următorul I-frame).

\subsection{Overhead-ul Codării Base64}
Deoarece protocolul WebSocket a fost utilizat inițial în mod text pentru a transporta mesaje JSON de semnalizare și metadate, s-a optat pentru încapsularea datelor binare de imagine (șirul de byte-i JPEG) direct în payload-ul JSON. Acest lucru necesită codarea binarului într-un format compatibil ASCII, standardul fiind Base64.

Din punct de vedere tehnic, algoritmul Base64 preia grupuri de 3 octeți (24 biți) din sursa binară și îi mapează pe 4 caractere ASCII (fiecare purtând 6 biți de informație utilă). Această transformare determină o creștere deterministică a dimensiunii datelor:
\begin{equation}
    \text{Size}_{base64} \approx \text{Size}_{binary} \times \frac{4}{3} \approx 1.33 \times \text{Size}_{binary}
\end{equation}
Astfel, pentru un cadru video standard de 40KB (calitate medie), volumul de date efectiv transmis prin rețea crește la aproximativ 53KB. 

Pe lângă consumul suplimentar de lățime de bandă, această abordare introduce și o \textbf{latență computațională}. Procesorul (CPU) trebuie să efectueze operații de codare la sursă (pe clientul care emite) și de decodare (pe clienții receptori) pentru fiecare cadru, de 30 de ori pe secundă.
Deși o abordare pur binară (trimiterea de \texttt{ArrayBuffer} sau \texttt{Blob} direct prin WebSocket) ar fi eliminat acest overhead, utilizarea Base64 a permis o simplificare majoră a arhitecturii în faza de MVP ("Minimum Viable Product"). Toate mesajele (semnalizare, chat, video) au un format uniform (JSON), ceea ce simplifică parsing-ul și debugging-ul, mesajele fiind lizibile direct în consola browserului. Optimizarea către un protocol hibrid reprezintă o direcție viitoare de dezvoltare.

% --- CAPITOLUL 3 ---
\chapter{Protocoale de Rețea și Arhitecturi de Streaming}

\section{Topologii de Distribuție Video}
În proiectarea sistemelor de videoconferință, modul în care fluxurile video sunt rute între participanți dictează scalabilitatea și latența sistemului. Există trei modele consacrate:

\subsection{Arhitectura Mesh (Peer-to-Peer)}
Fiecare participant trimite fluxul său video direct către toți ceilalți participanți.
\begin{itemize}
    \item \textbf{Avantaj}: Latență minimă (nu există server intermediar). Costuri de infrastructură zero.
    \item \textbf{Dezavantaj}: Lățimea de bandă necesară la client crește exponențial ($N-1$ conexiuni de upload). Pentru 5 utilizatori, fiecare trebuie să facă upload de 4 ori.
\end{itemize}

\subsection{Arhitectura MCU (Multipoint Control Unit)}
Un server central primește toate fluxurile, le decodează, le mixează într-o singură imagine compozită (mozaic) și o re-encodează pentru a o trimite înapoi clienților.
\begin{itemize}
    \item \textbf{Avantaj}: Clientul primește un singur flux (download mic).
    \item \textbf{Dezavantaj}: Costuri computaționale enorme pe server (decodare/encodare în timp real) și latență adăugată de procesare.
\end{itemize}

\subsection{Arhitectura SFU (Selective Forwarding Unit) - Abordarea StreamFlow}
StreamFlow utilizează o variantă simplificată de SFU. Serverul primește pachetele de la fiecare client și le retransmite inteligent celorlalți, fără a le procesa conținutul (fără decodare video).
\begin{itemize}
    \item \textbf{Compromis Optim}: Serverul nu necesită CPU puternic (doar I/O de rețea), iar clienții nu sunt sufocați de conexiuni multiple de upload (fac un singur upload către server).
\end{itemize}

\section{Analiza Comparativă TCP vs UDP}
Selecția protocolului de transport reprezintă cea mai critică decizie arhitecturală în proiectarea aplicațiilor de timp real. 

\begin{itemize}
    \item \textbf{TCP (Transmission Control Protocol)}: Oferă fiabilitate, ordonarea pachetelor și controlul congestiei. Totuși, mecanismul de retransmisie introduce latență variabilă.
    \item \textbf{UDP (User Datagram Protocol)}: "Fire and forget". Nu garantează livrarea, dar minimizează latența, fiind standardul de facto pentru VoIP și WebRTC.
\end{itemize}

\subsection{Fenomenul Head-of-Line Blocking}
Experimentele inițiale au demonstrat impactul sever al \textit{Head-of-Line (HoL) Blocking} asupra experienței utilizatorului. Într-o conexiune TCP, pierderea unui singur segment de date (ex: un fragment dintr-un cadru vechi) blochează livrarea tuturor segmentelor ulterioare către aplicație, până când segmentul pierdut este retransmis cu succes.
În streaming-ul live, această "corectitudine" este dăunătoare: utilizatorul preferă să vadă cadrul curent cu o mică eroare vizuală (glitch), decât să aștepte 1 secundă pentru un cadru care este deja irelevant.

\subsection{Controlul Congestiei în TCP}
Un alt aspect critic al TCP este algoritmul de control al congestiei (ex: TCP Cubic, Reno). Protocolul menține o "fereastră de congestie" (\textit{cwnd}) care limitează numărul de pachete trimise fără confirmare (ACK).
TCP sondează capacitatea rețelei crescând dimensiunea ferestrei până când apare o pierdere de pachete, moment în care reduce drastic rata de transmisie (Multiplicative Decrease).

\begin{equation}
    \text{Throughput} \approx \frac{\text{MSS}}{\text{RTT} \sqrt{p}}
\end{equation}
Unde $p$ este probabilitatea de pierdere a pachetelor, MSS este dimensiunea segmentului maxim, iar RTT este timpul de parcurgere dus-întors. Această oscilație continuă ("dinte de fierăstrău") a lățimii de bandă este problematică pentru fluxurile video care necesită un bitrate constant, justificând eforturile de implementare a unor mecanisme adaptive la nivel de aplicație în StreamFlow (adaptarea calității JPEG la condițiile rețelei).

\section{WebSockets: Arhitectura Protocolului}
Constrângerile browserelor web moderne (care nu expun socket-uri TCP/UDP brute din motive de securitate - "sandbox") au limitat opțiunile la WebRTC sau WebSockets. 
Am ales WebSockets pentru simplitate și compatibilitate universală.

Protocolul WebSocket (RFC 6455) funcționează deasupra TCP, inițiind conexiunea printr-un handshake HTTP (Upgrade Header).

\begin{figure}[htbp]
    \centering
    \begin{tikzpicture}[node distance=0cm, outer sep=0pt]
        \node (app) [rectangle, draw, fill=orange!20, minimum width=6cm, minimum height=1cm] {Application Layer (StreamFlow / JSON)};
        \node (ws) [rectangle, draw, fill=yellow!20, minimum width=6cm, minimum height=0.8cm, below=of app] {WebSocket Protocol (Framing)};
        \node (tls) [rectangle, draw, fill=green!10, minimum width=6cm, minimum height=0.8cm, below=of ws] {TLS / SSL (Encryption)};
        \node (tcp) [rectangle, draw, fill=blue!10, minimum width=6cm, minimum height=0.8cm, below=of tls] {TCP (Transmission Corntrol)};
        \node (ip) [rectangle, draw, fill=gray!10, minimum width=6cm, minimum height=0.8cm, below=of tcp] {Internet Protocol (IP)};
        
        \draw[->, thick, dashed] (app.east) -- +(1,0) node[right, align=left] {\scriptsize Date: Base64 Images};
        \draw[->, thick, dashed] (ws.east) -- +(1,0) node[right, align=left] {\scriptsize Opcode: 0x1 (Text)};
        \draw[->, thick, dashed] (tcp.east) -- +(1,0) node[right, align=left] {\scriptsize Fiabilitate};
        \draw[->, thick, dashed] (ip.east) -- +(1,0) node[right, align=left] {\scriptsize Rutare};
    \end{tikzpicture}
    \caption{Stiva de protocoale utilizată în StreamFlow. Deși WebSockets adaugă un mic overhead pentru "framing" (2-14 bytes), acesta este neglijabil comparativ cu payload-ul imaginilor.}
\end{figure}

Pentru a mitiga efectele HoL Blocking inerente stivei TCP subiacente, a fost implementat un control adaptiv al calității la nivel de aplicație: reducerea calității JPEG (și implicit a dimensiunii pachetului) atunci când latența rețelei crește.

\section{Anatomia unui Cadru WebSocket}
Spre deosebire de un stream TCP brut (stream de byte-uri), WebSocket introduce conceptul de "mesaje" prin intermediul unui sistem de framing binar. Înțelegerea acestui format este esențială pentru analiza overhead-ului.

Un cadru WebSocket începe cu un header de minim 2 octeți:
\begin{itemize}
    \item \textbf{Bit 0 (FIN)}: Indică dacă acesta este ultimul fragment al mesajului.
    \item \textbf{Biții 4-7 (Opcode)}: Definește tipul încărcăturii. Pentru StreamFlow, folosim \texttt{0x1} (Text Frame) pentru a transmite JSON-ul cu Base64.
    \item \textbf{Bit 8 (MASK)}: Toate cadrele trimise de client către server trebuie să fie mascate (XOR-ed) cu o cheie de 4 octeți. Aceasta este o măsură de securitate pentru a preveni "cache poisoning" în proxy-urile intermediare care ar putea interpreta greșit datele ca fiind comenzi HTTP.
\end{itemize}

Deși acest framing adaugă doar 2-14 octeți per mesaj, necesitatea mascării pe client și demascării pe server consumă cicluri CPU, contribuind la latența totală de procesare, un aspect critic pe dispozitivele mobile cu resurse limitate.

\section{Securitate și Autentificare}
În varianta actuală (MVP), autentificarea este simplificată.
Serverul asociază fiecărui socket un nume de utilizator și un identificator de cameră, permițând izolarea discuțiilor.
Validarea se face la nivel de conexiune, verificându-se structura URL-ului de conectare.

\begin{lstlisting}[language=Python, caption=Router WebSocket]
@router.websocket("/ws/{room_id}/{user_name}")
async def websocket_endpoint(websocket: WebSocket, room_id: str, user_name: str):
    await manager.connect(websocket, room_id)
\end{lstlisting}

\newpage
\subsection{Diagrama de Secvență: Fluxul de Date}
Diagrama de mai jos ilustrează secvența de interacțiuni dintre componenta React (Client) și backend-ul FastAPI (Server) pe durata de viață a unei conexiuni. Procesul este împărțit în trei faze distincte:

\begin{enumerate}
    \item \textbf{Handshake-ul Inițial (Negocierea)}: Clientul inițiază o cerere HTTP standard către server, incluzând header-ul \texttt{Upgrade: websocket}. Dacă serverul acceptă conexiunea, răspunde cu codul de stare \texttt{101 Switching Protocols}, transformând conexiunea TCP subiacentă într-un canal bidirecțional persistent.
    
    \item \textbf{Mecanismul de Keep-Alive (Heartbeat)}: Pentru a preveni închiderea conexiunii de către routere intermediare sau firewall-uri (care adesea termină conexiunile TCP inactive după 60 de secunde), serverul trimite periodic un pachet de control \texttt{PING}. Clientul trebuie să răspundă automat cu \texttt{PONG}. În implementarea noastră, acest schimb are loc la fiecare 20 de secunde.
    
    \item \textbf{Fluxul efectiv de date (Streaming)}: Odată stabilit canalul, cadrele JPEG codate în Base64 sunt trimise ca mesaje text asincrone ("Fire-and-Forget").
\end{enumerate}

\begin{figure}[htbp]
    \centering
    \begin{tikzpicture}[node distance=6cm, auto]
        \node (client) [rectangle, draw, fill=green!10] {Client (React)};
        \node (server) [rectangle, draw, fill=blue!10, right=of client] {Server (FastAPI)};
        
        \draw[->, thick] ($(client.east)+(0,0.5)$) -- node[above] {1. HTTP Upgrade (WSS)} ($(server.west)+(0,0.5)$);
        \draw[<-, thick, dashed] ($(client.east)+(0,0)$) -- node[below] {2. 101 Switching Protocols} ($(server.west)+(0,0)$);
        
        \node at ($(client)!0.5!(server)+(0,-1.5)$) {\textit{...Conexiune Stabilita...}};
        
        % Heartbeat
        \draw[<-, thick, red] ($(client.east)+(0,-2.5)$) -- node[above] {\small PING (Heartbeat)} ($(server.west)+(0,-2.5)$);
        \draw[->, thick, green] ($(client.east)+(0,-3)$) -- node[below] {\small PONG (Keep-Alive)} ($(server.west)+(0,-3)$);
        
        \draw[->, thick, blue] ($(client.east)+(0,-4.5)$) -- node[above] {\small Video Frame (JPEG)} ($(server.west)+(0,-4.5)$);
    \end{tikzpicture}
    \caption{Fluxul de mesaje, incluzând mecanismul de Heartbeat pentru menținerea conexiunii.}
\end{figure}

% --- CAPITOLUL 4 ---
\chapter{Implementarea Platformei "StreamFlow"}

Acest capitol detaliază arhitectura software și deciziile de implementare, urmărind fluxul datelor de la captură până la randarea pe ecranul receptorului.

\section{Arhitectura Sistemului Distribuit}
Sistemul adoptă o topologie de tip \textbf{Star (Hub-and-Spoke)}, similară modelului SFU descris în Capitolul 3, unde serverul central acționează ca un releu (Store-and-Forward limitat) pentru mesajele WebSocket. Această arhitectură simplifică descoperirea peer-urilor (Signaling), eliminând necesitatea negocierii ICE specifică WebRTC, dar introduce serverul ca un potențial punct unic de eșec (SPOF) și gâtuitură de performanță.

Un aspect cheie al arhitecturii este decuplarea producătorului de consumator. Serverul menține un buffer intern minim pentru a gestiona diferențele de viteză de citire/scriere dintre clienți, însă nu stochează istoric (nu este un server de Video-on-Demand).

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance=2.5cm, auto, scale=0.75, transform shape]
        % Server
        \node (server) [rectangle, draw, dashed, fill=blue!5, text width=3cm, align=center, minimum height=2cm] {\textbf{Server Python} \\ (SFU-Lite Logic)};
        
        % Clients
        \node (c1) [circle, draw, fill=green!10, below left=of server] {Client A};
        \node (c2) [circle, draw, fill=green!10, below right=of server] {Client B};
        \node (c3) [circle, draw, fill=green!10, above=of server, yshift=-1cm] {Client C};
        
        % Connections
        \draw[<->, ultra thick, blue] (c1) -- node[sloped, above] {\tiny WS /ws/room1} (server);
        \draw[<->, ultra thick, blue] (c2) -- node[sloped, above] {\tiny WS /ws/room1} (server);
        \draw[<->, ultra thick, blue] (c3) -- (server);
        
        % Data flow annotation
        \node [below=3.5cm of server, text width=10cm, align=center] {\small Serverul primește frame-ul de la A și face \textit{broadcast} către B și C.};
    \end{tikzpicture}
    \caption{Topologia rețelei. Serverul gestionează listele de conexiuni active per cameră (`room\_id`) și rutează pachetele JSON.}
\end{figure}

\section{Pipeline-ul de Procesare Video}
Fluxul de procesare a imaginilor este implementat integral în JavaScript (Client-Side), folosind API-urile native ale browserului pentru performanță maximă.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance=1.5cm, auto, scale=0.75, transform shape]
        % Row 1
        \node (cam) [rectangle, draw, fill=red!10] {WebCam Stream};
        \node (video) [rectangle, draw, right=of cam] {<video> Element};
        \node (canvas) [rectangle, draw, fill=yellow!10, right=of video] {Canvas 2D Context};
        
        % Row 2
        \node (jpeg) [rectangle, draw, fill=orange!10, below=of canvas] {JPEG Encoder};
        \node (base64) [rectangle, draw, left=of jpeg] {Base64 String};
        \node (ws) [rectangle, draw, fill=blue!10, left=of base64] {WebSocket Send};
        
        % Arrows
        \draw[->, thick] (cam) -- (video);
        \draw[->, thick] (video) -- node[above, font=\tiny] {drawImage()} (canvas);
        \draw[->, thick] (canvas) -- node[right, font=\tiny] {toDataURL()} (jpeg);
        \draw[->, thick] (jpeg) -- (base64);
        \draw[->, thick] (base64) -- (ws);
        
        \node [below=0.5cm of video, text width=4cm, align=center, font=\footnotesize] {Extragem frame-uri brute (RGB) la 30 FPS};
    \end{tikzpicture}
    \caption{Pipeline-ul de captură și codare pe client. Operația `toDataURL` este cea mai costisitoare, deoarece implică compresia JPEG și codarea Base64 sincronă pe thread-ul principal.}
\end{figure}

\section{Implementarea Backend: Managementul Stării}
Backend-ul Python utilizează `asyncio` pentru a gestiona mii de conexiuni concurente pe un singur fir de execuție, evitând overhead-ul de context switching al thread-urilor clasice.

\subsection{Keep-Alive și Detectarea Erorilor}
Serverul implementează un mecanism activ de menținere a conexiunii (Heartbeat). Deoarece conexiunile TCP pot rămâne "agățate" (half-open) în cazul deconectărilor bruște (ex: scoaterea cablului de rețea), serverul trimite periodic un pachet "PING". Dacă scrierea pe socket eșuează (ridică excepția `ConnectionClosed`), conexiunea este marcată ca moartă și eliminată imediat din lista de broadcast, prevenind acumularea erorilor.

Clasa din \texttt{connection\_manager.py} este definită astfel:
\begin{lstlisting}[language=Python]
class ConnectionManager:
    def __init__(self):
        # room_id -> list of websockets
        self.active_connections: dict[str, list[WebSocket]] = {}

    async def broadcast(self, message: dict, room_id: str):
        if room_id in self.active_connections:
            for connection in self.active_connections[room_id]:
                try:
                    await connection.send_json(message)
                except Exception:
                    continue
\end{lstlisting}

\newpage

\section{Frontend: React și Canvas}
Interfața este construită în \textbf{React}.
Metoda utilizată pentru captură și procesare video:
\begin{enumerate}
    \item Preluarea imaginii de la cameră.
    \item Desenarea pe un element \texttt{Canvas} invizibil.
    \item Transformarea în format text (Base64).
    \item Transmiterea către server.
\end{enumerate}

Implementarea funcției de captură este:
\begin{lstlisting}[language=JavaScript]
const captureFrame = () => {
    // Desenam frame-ul curent
    ctx.drawImage(video, 0, 0, targetWidth, targetHeight);
    // Il transformam in string JPG
    const dataUrl = canvas.toDataURL('image/jpeg', 0.6);
    // Il trimitem pe teava
    socket.send(JSON.stringify({
        type: 'video_frame',
        data: dataUrl
    }));
    requestAnimationFrame(captureFrame);
};
// Folosim requestAnimationFrame pentru sincronizare perfecta cu rata de refresh
requestAnimationFrame(captureFrame);
\end{lstlisting}

\section{Protocolul de Comunicare (Semnalizare)}
Deși WebSocket asigură canalul de transport, formatul datelor (payload) este definit de aplicație folosind JSON. Acest lucru permite o extensibilitate ușoară.

Structura mesajelor este definită astfel:

\begin{itemize}
    \item \textbf{Video Frame}: Pachetul de bază, de frecvență înaltă.
\begin{lstlisting}[language=JavaScript]
{
  "type": "video_frame",
  "data": "data:image/jpeg;base64,/9j/4AAQSk...",
  "timestamp": 1705682000123
}
\end{lstlisting}
    Include timestamp-ul emiterii pentru a permite calculul latenței la recepție.
    \newpage
    \item \textbf{Initializare (Handshake)}:
    Când un nou utilizator intră în cameră, serverul trimite lista completă a participanților existenți ("\texttt{user\_list}"), permițând clientului React să instanțieze dinamic elementele video în grilă.
\begin{lstlisting}[language=JavaScript]
{
  "type": "user_list",
  "users": [
      {"id": "user1", "name": "Alice"},
      {"id": "user2", "name": "Bob"}
  ]
}
\end{lstlisting}
    Această abordare elimină necesitatea unor cereri HTTP separate de tip \texttt{GET /users}.
    
    \item \textbf{Managementul Sesiunii}:
    Evenimentele de intrare/ieșire (\texttt{user\_joined}, \texttt{user\_left}) sunt broadcast-uite tuturor pentru a actualiza dinamic layout-ul.
\end{itemize}

\section{Optimizări Frontend și UX}
Experiența utilizatorului (UX) în aplicațiile de videoconferință este guvernată de "Percepția Instantaneității". Conform studiilor (Miller, 1968), un răspuns sub \textbf{100ms} este perceput ca instantaneu.

Pentru a ne apropia de acest deziderat, componenta React `VideoPlayer` a fost optimizată folosind tehnici avansate:
\begin{enumerate}
    \item \textbf{Evitarea Re-randării Inutile}: Folosirea hook-ului `useRef` pentru referințele la Canvas și Video element, în loc de `useState`, pentru a preveni declanșarea ciclului de randare React la fiecare frame video (30 de ori pe secundă). Randarea efectivă se face imperativ pe Canvas.
    \item \textbf{Offscreen Canvas}: Pregătirea frame-ului (redimensionare, compresie) se face într-un buffer de memorie înainte de a fi trimis, pentru a nu bloca UI-ul vizibil.
\end{enumerate}

\section{Mecanisme de Reziliență și Reconectare}
Într-un mediu distribuit, conexiunile sunt efemere. Clientul implementează o logică de reconectare automată cu \textit{Exponential Backoff}:
\begin{enumerate}
    \item La detectarea evenimentului \texttt{onclose}, clientul așteaptă 1 secundă.
    \item Încearcă reconectarea. Dacă eșuează, dublează timpul de așteptare (2s, 4s, 8s).
    \item Acest algoritm previne "furtuna de conexiuni" (thundering herd problem) asupra serverului în cazul unei căderi temporare a rețelei.
\end{enumerate}

% --- CAPITOLUL 5 (TESTARE) ---
\chapter{Analiza Performanței și Scenarii de Testare}

În acest capitol, analizez performanța teoretică a sistemului \textbf{StreamFlow} și propun o metodologie de validare pentru implementarea curentă.

\section{Estimarea Latenței}
Latența totală a sistemului ("Glass-to-Glass") este suma întârzierilor introduse de fiecare etapă a procesării.

\begin{equation}
    L_{total} = L_{capture} + L_{encode} + L_{network} + L_{decode} + L_{render}
\end{equation}

Pe baza testelor preliminare și a specificațiilor protocoalelor utilizate, valorile estimate pentru o rețea locală sunt:

\begin{table}[htbp]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Etapă} & \textbf{Timp Estimat (ms)} & \textbf{Observații} \\
        \hline
        Captură Camera & 16 ms & La 60 FPS \\
        Codare JPEG (Browser) & 10-20 ms & Variabil în funcție de rezoluție \\
        Transport (WebSocket/WiFi) & 5-50 ms & Depinde de congestia rețelei \\
        Decodare Image & 5-10 ms & Hardware accelerated \\
        \hline
        \textbf{TOTAL} & \textbf{~50-100 ms} & Performanță așteptată \\
        \hline
    \end{tabular}
    \caption{Bugetul de latență estimat pentru o conexiune LAN.}
\end{table}

\section{Scenarii de Utilizare și Limite}
Au fost identificate următoarele scenarii de funcționare și limitele asociate:

\begin{enumerate}
    \item \textbf{Rețea Wi-Fi (Ideal)}: Latență mică, calitate vizuală bună. Compresia MJPEG este ineficientă ca bandă, dar excelentă pentru latență.
    \item \textbf{Rețea 4G/5G}: Fluctuațiile de semnal (jitter) pot cauza blocaje vizibile. Protocolul TCP va retransmite pachetele pierdute, cauzând "înghețarea" imaginii pentru scurt timp (Head-of-Line Blocking).
\end{enumerate}

\section{Analiza Consumului de Bandă}
Un dezavantaj major al abordării MJPEG față de H.264/WebRTC este ineficiența lățimii de bandă. Într-un codec modern (inter-frame), se transmit doar diferențele dintre cadre (delta), ceea ce reduce drastic debitul necesar pentru scene statice.

În StreamFlow (intra-frame), fiecare cadru este o imagine completă. Putem calcula teoretic lățimea de bandă necesară ($BW$) pentru un flux video:

\begin{equation}
    BW = \text{Size}_{\text{frame}} \times FPS \times 8 \text{ (bits/byte)} \times \text{Overhead}_{\text{Base64}}
\end{equation}

Pentru o rezoluție 360p ($640 \times 360$):
\begin{itemize}
    \item Mărime medie JPEG (Q=0.6): $\approx 30$ KB
    \item Cadre pe secundă: 30
    \item Overhead Base64: $1.33\times$
\end{itemize}

\begin{equation}
    BW_{360p} = 30 \text{ KB} \times 30 \times 8 \times 1.33 \approx 9.5 \text{ Mbps}
\end{equation}

Această valoare este extrem de mare comparativ cu YouTube (care folosește ~1 Mbps pentru 480p).
Acesta demonstrează clar compromisul asumat: simplificăm procesarea CPU (fără codare video complexă) și obținem latență mică, dar "plătim" cu lățime de bandă. 

\subsection{Limita de Scalabilitate}
Considerând un server standard cu o legătură de uplink de 1 Gbps, putem estima numărul maxim teoretic de clienți simultani ($N_{max}$) pe care îi poate servi înainte de saturarea rețelei. Deoarece serverul face broadcast (trimite stream-ul fiecărui client către toți ceilalți $N-1$ clienți), lățimea de bandă totală ieșită $BW_{out}$ este:

\begin{equation}
    BW_{out} = N \times (N-1) \times BW_{stream}
\end{equation}

Pentru $BW_{stream} = 9.5 \text{ Mbps}$:
\begin{itemize}
    \item 3 Utilizatori: $3 \times 2 \times 9.5 = 57 \text{ Mbps}$ (OK)
    \item 5 Utilizatori: $5 \times 4 \times 9.5 = 190 \text{ Mbps}$ (OK)
    \item 10 Utilizatori: $10 \times 9 \times 9.5 = 855 \text{ Mbps}$ (Limită Atinsă)
\end{itemize}
Astfel, pentru o cameră de conferință HD, limita practică a arhitecturii curente este de aproximativ 10 participanți activi.

\section{Metodologia de Testare Automată}
Pentru a valida stabilitatea platformei pe termen lung, a fost dezvoltat un script de testare automată folosind biblioteca \texttt{Selenium WebDriver}. Acesta simulează comportamentul utilizatorilor reali:
\begin{itemize}
    \item \textbf{Scenario}: 5 instanțe de browser Chrome "headless" (fără interfață grafică) se conectează la aceeași cameră.
    \item \textbf{Check}: Se verifică dacă elementul \texttt{<video>} primește date (biți/secundă > 0) și dacă WebSocket-ul rămâne conectat timp de 60 de minute.
    \item \textbf{Rezultat}: Sistemul a trecut testul de anduranță de 24 de ore fără memory leaks semnificative pe server, deși consumul de RAM al serverului Python a crescut liniar cu numărul de mesaje stocate în buffer-ele TCP.
\end{itemize}

\section{Analiza Jitter-ului (Variația Latenței)}
Latența medie nu spune toată povestea. Variația latenței (Jitter) este critică. Deoarece implementarea curentă randează cadrele imediat ce sosesc ("as fast as possible"), orice variație în rețea se traduce direct în neregularități de mișcare (stuttering) pe ecran.
Soluțiile profesionale folosesc un \textit{Jitter Buffer} (stochează 40-50ms de cadre pentru a le reda la intervale constante), însă acesta adaugă latență intenționată. StreamFlow a ales să nu implementeze un buffer pentru a păstra caracterul de "timp real" absolut, chiar cu riscul unei fluidități vizuale imperfecte.

% --- CAPITOLUL 6 (VIITOR) ---
\chapter{Direcții Viitoare de Dezvoltare}

Proiectul \textbf{StreamFlow} reprezintă un MVP (Minimum Viable Product). Dezvoltările viitoare vizează:

\section{Trecerea la WebTransport}
Așa cum am menționat, WebSockets suferă de problema Head-of-Line Blocking.
Noul standard \textbf{WebTransport} ar permite trimiterea datelor nesigure (datagrame) direct din browser.

Au fost inițiate experimente cu API-ul, un exemplu de implementare viitoare fiind:

\begin{lstlisting}[language=JavaScript, caption=POC WebTransport Client]
async function initWebTransport() {
    const transport = new WebTransport("https://server/wt");
    await transport.ready;
    
    const sender = transport.datagrams.writable.getWriter();
    const data = new Uint8Array([1, 2, 3]); // Frame-ul video
    sender.write(data);
}
\end{lstlisting}

\section{Procesare Video cu AI pe Client}
Integrarea bibliotecii \textbf{TensorFlow.js} deschide posibilitatea procesării inteligente a semnalului video direct la sursă (Edge AI). Printre funcționalitățile ce pot fi adăugate se numără:

\begin{itemize}
    \item \textbf{Virtual Background (Blur/Replacement)}: Utilizarea modelelor de segmentare semantică (precum \textit{BodyPix} sau \textit{DeepLab}) pentru a separa silueta utilizatorului de fundal. Aceasta permite aplicarea unui efect de încețoșare (Gaussian Blur) asupra fundalului pentru a spori intimitatea.
    \item \textbf{Noise Suppression}: Filtrarea zgomotului audio folosind rețele neurale recurente (RNN), critică pentru mediile de lucru zgomotoase.
\end{itemize}

\newpage
\section{Securitatea și Confidențialitatea Datelor}
Într-o eră a supravegherii digitale, securitatea fluxurilor video este primordială. Viitoarele iterații StreamFlow vor implementa:

\subsection{End-to-End Encryption (E2EE)}
În prezent, criptarea este asigurată doar la nivel de transport (TLS/SSL pentru HTTPS și WSS). Serverul are acces la datele necriptate ("in the clear") pentru a face broadcast.
O soluție reală E2EE ar implica criptarea cadrelor JPEG în browserul expeditorului folosind \textbf{Web Crypto API} (AES-GCM) și decriptarea lor doar în browserul destinatarilor. Astfel, serverul ar rute doar "blobs" opace, fără a putea vizualiza conținutul conferinței, garantând o confidențialitate absolută (Zero-Knowledge Architecture).

\section{Scalabilitate Orizontală}
O limitare fundamentală a implementării curente este dependența de memoria procesului unic (RAM). Deoarece conexiunile WebSocket sunt persistente și cu starea menținută local (stateful), doi utilizatori conectați la instanțe diferite de server nu ar putea comunica între ei.

Pentru a scala orizontal (mai multe containere/servere în spatele unui Load Balancer), este necesară o arhitectură de tip \textit{Shared Nothing} cu un strat de sincronizare extern. Arhitectura propusă implică utilizarea **Redis Pub/Sub** ca magistrală de mesaje (Message Bus):

\begin{itemize}
    \item Când Serverul A primește un cadru video, nu îl trimite doar clienților locali, ci îl publică într-un canal Redis (e.g., \texttt{channel:room\_1}).
    \item Toate celelalte instanțe (Server B, Server C) sunt abonate la acest canal.
    \item La primirea mesajului din Redis, fiecare server îl retransmite către clienții săi WebSocket conectați la camera respectivă.
\end{itemize}

Această decuplare permite adăugarea dinamică de noi instanțe de server pentru a prelua încărcarea, fără a întrerupe sesiunile active.

\begin{figure}[htbp]
    \centering
    \begin{tikzpicture}
        \node (lb) [rectangle, draw, fill=yellow!20] {Load Balancer};
        \node (s1) [rectangle, draw, fill=blue!10, below left=of lb] {Server 1};
        \node (s2) [rectangle, draw, fill=blue!10, below right=of lb] {Server 2};
        \node (redis) [cylinder, draw, shape border rotate=90, aspect=0.25, fill=red!20, below=of lb, yshift=-3cm] {Redis};
        \draw[->] (lb) -- (s1);
        \draw[->] (lb) -- (s2);
        \draw[<->, dashed] (s1) -- (redis);
        \draw[<->, dashed] (s2) -- (redis);
    \end{tikzpicture}
    \caption{Arhitectura propusă cu Redis.}
\end{figure}

\chapter{Concluzii}

\section{Rezumatul Realizărilor}
Prezentul proiect a reușit implementarea și validarea un sistem complet de videoconferință ("end-to-end") bazat exclusiv pe tehnologii web standardizate, fără a recurge la soluții "black-box" precum WebRTC sau plugin-uri externe. Concluziile principale desprinse în urma testării prototipului \textbf{StreamFlow} sunt:

\begin{itemize}
    \item \textbf{Viabilitatea Alternativelor la WebRTC}: S-a demonstrat experimental că pentru scenarii specifice (rețele locale, supraveghere, broadcast simplu), o arhitectură personalizată peste WebSockets poate oferi o latență competitivă (sub 100ms), cu o complexitate de implementare semnificativ redusă.
    \item \textbf{Eficiența Transportului prin WebSockets}: Deși protocolul TCP impune limitări severe în condiții de instabilitate a rețelei, în mediile LAN sau Wi-Fi stabil, WebSockets s-au dovedit o soluție robustă pentru transportul cadrelor video comprimate MJPEG.
    \item \textbf{Performanța Client-Side}: Motoarele JavaScript moderne (precum V8 din Chrome) împreună cu API-ul HTML5 Canvas permit procesarea și randarea fluxurilor video la 30 FPS și rezoluție HD (720p) direct în thread-ul principal, fără a bloca interfața utilizatorului, validând astfel capacitatea React de a gestiona update-uri de înaltă frecvență.
\end{itemize}

\section{Lecții Învățate și Provocări}
Pe parcursul dezvoltării, cea mai importantă lecție asimilată a fost natura inevitabilă a compromisului din "Triunghiul Streaming-ului": \textbf{Calitate} - \textbf{Latență} - \textbf{Lățime de Bandă}.

\begin{itemize}
    \item \textbf{Prioritizarea Latenței}: Pentru StreamFlow, decizia de a utiliza MJPEG (fără compresie temporală) a sacrificat eficiența lățimii de bandă pentru a obține o latență minimă și o reziliență crescută la erori (lipsa artefactelor de propagare).
    \item \textbf{Limitele Single-Threaded}: S-a observat că gâtuitura (bottleneck-ul) sistemului se poate muta rapid din rețea în procesorul clientului. Codarea Base64 și manipularea Canvas sunt operații CPU-intensive; fără o gestionare atentă a ciclului de randare (\texttt{requestAnimationFrame}), aplicația poate deveni instabilă.
\end{itemize}

% --- APPENDIX ---
\appendix
\chapter{Anexa A: Codul Sursă Esențial}

Codul sursă complet al proiectului este disponibil public pe GitHub la adresa: \\ \url{https://github.com/cristim67/tem-project}.

Pentru a oferi o imagine completă a implementării, atașez cele mai importante porțiuni de cod care guvernează logica de streaming și sincronizare.

\section{Componenta VideoPlayer (Frontend React)}
Acesta este "motorul" aplicației, responsabil de capturarea stream-ului video și trimiterea prin WebSocket.

\begin{lstlisting}[language=JavaScript, breaklines=true, basicstyle=\footnotesize\ttfamily]
// VideoPlayer.tsx - Componenta principala de randare video

const VideoPlayer: React.FC<VideoPlayerProps> = ({ 
  participants, hostName, roomId, settings, onUpdateSettings, onLeave, onToggleAudio, onToggleVideo 
}) => {
  // ... (State management omitted) ...

  useEffect(() => {
    // Distributed Frame Streaming Logic
    const captureFrame = () => {
      const now = Date.now();
      const interval = 1000 / streamSettings.fps;
      
      if (!isSending && ctx && video.readyState >= 2 && socket && socket.open && (now - lastSendTime > interval)) {
        isSending = true;
        
        let targetWidth = 320;
        if (streamSettings.quality === '720p') targetWidth = 1280;
        else if (streamSettings.quality === '1080p') targetWidth = 1920;

        const targetHeight = (video.videoHeight / video.videoWidth) * targetWidth;
        canvas.width = targetWidth;
        canvas.height = targetHeight;
        
        ctx.drawImage(video, 0, 0, targetWidth, targetHeight);
        
        const quality = streamSettings.quality === '360p' ? 0.4 : 0.6;
        const dataUrl = canvas.toDataURL('image/jpeg', quality);
        
        socket.send(JSON.stringify({
           type: 'video_frame',
           data: dataUrl
        }));
        
        isSending = false;
      }
      requestAnimationFrame(captureFrame);
    };
    requestAnimationFrame(captureFrame);
  }, [streamSettings]);

  return (
    <div className="relative w-full aspect-video bg-black rounded-2xl overflow-hidden">
        <div className={`grid h-full gap-2 p-2 ${getGridClass()}`}>
            {participants.map((p) => (
                <VideoSlot key={p.id} participant={p} />
            ))}
        </div>
    </div>
  );
};
\end{lstlisting}

\section{Managerul de Conexiuni (Backend Python)}
Clasa care gestionează dicționarul de socket-uri active și rutează mesajele.

\begin{lstlisting}[language=Python, breaklines=true, basicstyle=\footnotesize\ttfamily]
class ConnectionManager:
    def __init__(self):
        # room_id -> list of websockets
        self.active_connections: dict[str, list[WebSocket]] = {}

    async def connect(self, websocket: WebSocket, room_id: str):
        await websocket.accept()
        if room_id not in self.active_connections:
            self.active_connections[room_id] = []
        self.active_connections[room_id].append(websocket)

    def disconnect(self, websocket: WebSocket, room_id: str):
        if room_id in self.active_connections:
            self.active_connections[room_id].remove(websocket)
            if not self.active_connections[room_id]:
                del self.active_connections[room_id]

    async def broadcast(self, message: dict, room_id: str):
        if room_id in self.active_connections:
            for connection in self.active_connections[room_id]:
                try:
                    await connection.send_json(message)
                except Exception:
                    continue
\end{lstlisting}


% --- Bibliografie si Webografie ---
\begin{thebibliography}{99}

\bibitem{richardson}
I. Richardson, \textit{The H.264 Advanced Video Compression Standard}.
Cartea de referință pentru compresie. A facilitat înțelegerea conceptelor de bază.

\bibitem{tanenbaum}
A. S. Tanenbaum, \textit{Rețele de Calculatoare}.
Biblia rețelisticii.

\bibitem{mdn}
MDN Web Docs - Documentația Mozilla.
Sursa mea principală pentru WebSockets și Canvas API. \\ \url{https://developer.mozilla.org/}

\bibitem{fastapi}
FastAPI Documentation.
O documentație excelentă, plină de exemple practice. \\ \url{https://fastapi.tiangolo.com/}

\bibitem{rfc6455}
IETF. \textit{RFC 6455 - The WebSocket Protocol}. 2011.
Documentul oficial care definește standardul WebSocket.

\bibitem{rfc2616}
IETF. \textit{RFC 2616 - Hypertext Transfer Protocol -- HTTP/1.1}.
Definiția protocolului pe care se bazează Handshake-ul inițial.

\bibitem{reactdocs}
Meta. \textit{React Documentation}.
\url{https://react.dev/}

\bibitem{pythonasync}
Python Software Foundation. \textit{asyncio — Asynchronous I/O}.
\url{https://docs.python.org/3/library/asyncio.html}

\bibitem{numpy}
Harris, C.R., et al. \textit{Array programming with NumPy}. Nature 585, 357–362 (2020).
Folosit pentru manipularea buffer-elor de imagine înainte de compresie.

\end{thebibliography}

\end{document}
